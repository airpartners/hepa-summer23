```{r}
# Imports
library(reticulate)
library(pracma)
library(dplyr)
library(minpack.lm)
library(broom)
```

```{r}
# Get indoor/outdoor ratio and add that to main dataframe
joined_data$in_out_pm1 <-
    joined_data$indoor_pm1 / joined_data$outdoor_pm1

joined_data$in_out_pm25 <-
    joined_data$indoor_pm25 / joined_data$outdoor_pm25

joined_data$in_out_pm10 <-
    joined_data$indoor_pm10 / joined_data$outdoor_pm10
```

```{r}
# Create separate variables to replace NA values
in_out_pm1 <- joined_data$in_out_pm1

in_out_pm25 <- joined_data$in_out_pm25

in_out_pm10 <- joined_data$in_out_pm10
```

```{r}
# Replace NA values with 0
in_out_pm1[is.na(in_out_pm1)] <- 0

in_out_pm25[is.na(in_out_pm25)] <- 0

in_out_pm10[is.na(in_out_pm10)] <- 0
```

```{r}
# Plot indoor/outdoor ratios for each pollutant
timePlot(joined_data, pollutant = c('in_out_pm1', 'in_out_pm25', 'in_out_pm10'), normalize = TRUE)

timePlot(joined_data, pollutant = 'in_out_pm1', normalize = TRUE)

timePlot(joined_data, pollutant = 'in_out_pm25', normalize = TRUE)

timePlot(joined_data, pollutant = 'in_out_pm10', normalize = TRUE)
```

```{r}
# Find peaks and store in new dataframes
peaks_pm1 <- get_peaks(in_out_pm1)

peaks_pm25 <- get_peaks(in_out_pm25)

peaks_pm10 <- get_peaks(in_out_pm10)
```

```{r}
# Find the first valley after each peak
valleys_pm1 <- get_first_valleys(in_out_pm1, peaks_pm1, 2)

valleys_pm25 <- get_first_valleys(in_out_pm25, peaks_pm25, 2)

valleys_pm10 <- get_first_valleys(in_out_pm10, peaks_pm10, 2)
```

```{r}
# Find the decay value (k constant) for each peak
decays_pm1 <- curve_fitting(in_out_pm1, peaks_pm1, valleys_pm1)

decays_pm25 <- curve_fitting(in_out_pm25, peaks_pm25, valleys_pm25)

decays_pm10 <- curve_fitting(in_out_pm10, peaks_pm10, valleys_pm10)
```

```{r}
# Plot the time series with the peaks and first valleys plotted on top
plot_peaks_valleys(in_out_pm1, peaks_pm1, valleys_pm1)

plot_peaks_valleys(in_out_pm25, peaks_pm25, valleys_pm25)

plot_peaks_valleys(in_out_pm10, peaks_pm10, valleys_pm10)
```

```{r}
# Take the mean/median of the decay constants
mean_pm1 <- mean(decays_pm1$k_val)
median_pm1 <- median(decays_pm1$k_val)

mean_pm25 <- mean(decays_pm25$k_val)
median_pm25 <- median(decays_pm25$k_val)

mean_pm10 <- mean(decays_pm10$k_val)
median_pm10 <- median(decays_pm10$k_val)
```

# Necessary functions to perform decay analysis
```{r}
# Function to get first valley after peak
get_first_valleys <- function(data, peaks, min_threshold) {
  # Iterate through rows of peaks matrix
  valley_mat <- matrix(nrow = nrow(peaks), ncol = 2)
  for (row in 1:nrow(peaks)) { #nolint
    idx <- peaks[row, 2]
    n <- TRUE
    # create while loop to check for local minima
    while (n) {
      # if we're at the end of y, break out of loop
      if (idx == length(data)) {
        n <- FALSE
      } else {
        # otherwise, get slope (approximately)
        # NOTE: difference between idx and (idx+1) is 1
        slope <- data[idx + 1] - data[idx]
        if (data[idx] <= min_threshold && slope > 0) {
          n <- FALSE
        } else {
          idx <- idx + 1
        }
      }
    }
    # set values of matrix so that column 1 is height of valley and 2 is index
    valley_mat[row, 1] <- data[idx]
    valley_mat[row, 2] <- idx
  }
  valley_mat
}
```

```{r}
# Function for exponential curve fitting for air quality data; returns 
# dataframe containing k-values of curves
curve_fitting <- function(data, peaks, valleys) {
    # Create empty dataframe for storing k values
  alphas.data <- data.frame(
    "peak_idx" = numeric(0),
    "valley_idx" = numeric(0),
    "peak_hgt" = numeric(0),
    "k_val" = numeric(0),
    "conv_tol" = numeric(0)
  )
  # Define parameters for curve fitting function for each row
 for (row in 1:nrow(peaks)) 
  {
    i_range <- peaks[row, 2]:valleys[row, 2]
    sect <- data[i_range]
    t <- i_range - peaks[row, 2] + 1
    df <- data.frame(t = t, y = sect)
    # Get exponential fit
    alphas.newdata <- tryCatch({
      fit <- nls(y ~ SSasymp(t, yf, y0, log_alpha), data = df)
      # Get parameters of the fit
      params <- coef(fit)
      # Extract the log_alpha value and put it in form e^(log(a)) to get a
      log_alpha <- as.double(params["log_alpha"])
      alpha <- exp(log_alpha)
      # Get achieved convergence tolerance as metric for accuracy of fit
      # NOTE: R^2 value can be calculated but is not a useful metric
      # for nonlinear models
      conv <- fit$convInfo$finTol
      # Add alpha to dataframe
      alphas.newdata <- data.frame(
        "peak_idx" = c(peaks[row, 2]),
        "valley_idx" = c(valleys[row, 2]),
        "peak_hgt" = c(peaks[row, 1]),
        "k_val" = c(alpha),
        "conv_tol" = c(conv)
      )
      }, error = function(e) {
      }, warning = function(w) {
      }, finally = {
      })
      alphas.data <- rbind(alphas.data, alphas.newdata)
  }
  alphas.data <- arrange_all(alphas.data)
  return(alphas.data)
}
```

```{r}
# Function to plot the peaks and valleys on top of current time series
plot_peaks_valleys <- function(data, peaks, valleys) {
  plot(data,
  type = "l",
  main = "Indoor/Outdoor Ratio",
  xlab = "Time (minutes)",
  ylab = "Ratio of indoor/outdoor concentrations",
  col = "navy")
  grid()
points(peaks[, 2], peaks[, 1], pch = 20, col = "maroon")
points(valleys[, 2], valleys[, 1], pch = 20, col = "green")
}
```

```{r}
# Function to get the peaks of a dataset
get_peaks <- function(data) {
  findpeaks(data,
                   nups = 1,
                   ndowns = 1,
                   minpeakheight = 10,
                   minpeakdistance = 200,
                   threshold = 0)
}
```


```{r}
# # Extra code to graph data and exponential decay curve to see fit (needs to be modified)
# row = 1
# idx_range <- peaks_pm1[row, 2]:valleys_pm1[row, 2]
# sect <- in_out_pm1[idx_range]
# t <- idx_range - peaks_pm1[row, 2] + 1
# single_decay <- data.frame(t = t, y = sect)
# 
# print(single_decay)
# 
# fit <- nls(y ~ SSasymp(t, yf, y0, log_alpha), data = single_decay)
# print(fit)
# 
# params <- coef(fit)
# log_alpha <- as.double(params["log_alpha"])
# alpha <- exp(log_alpha)
# print(alpha)
# 
# # Graphing for just scatterplot
# ggplot(data = single_decay, mapping = aes(x = t, y = y)) +
#   geom_point()
# 
# # Graphing for both
# qplot(t, y, data = augment(fit)) + geom_line(aes(y = .fitted), colour = "red")
```

# Concerns
- we are just not including half the peaks (anything that gets flagged as an
error)
- the data doesn't look quite the same as the initial time series

