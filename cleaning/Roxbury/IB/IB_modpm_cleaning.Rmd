# Modulair-PM Data Cleaning
This file cleans, and calculates the I/O ratio for Mod-PM data. Output is saved in a `modpm.RData` file that is *untracked* by Github. *All files that depend on using Mod-PM data must be run after running this file.*


## Set up
Load libraries, define file paths, include participant IDs to be processed
```{r}
# Import relevant libraries
library(tidyverse)
library(readxl)
```
Set working directory
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/vkuchhal/Documents/hepa-summer23")
```

```{r}
# Get file path
if (!endsWith(getwd(), "hepa-summer23")) {
  stop("Incorrect working directory")
}
```

```{r}
# Read summary table of times
time_map <- read_excel("data/Roxbury/IB/IB_notes_summarized.xlsx") %>%
  # Convert to appropriate variable types
  mutate(across(c(dt_start, dt_hepa, dt_end), 
                  ~as.POSIXct(.x, format = "%m/%d/%Y %H:%M"))) %>%
  mutate(across(c(dt_start, dt_hepa, dt_end), 
                  ~force_tz(.x, tz = "America/New_York")))
```


```{r}
# Set path to data
path_to_data <- "data/Roxbury/IB/modpm/"

# Set data category
data_cat <- "IB_M"
```

## Helper Functions
The following two functions are used to clean and process the data

### Reformatting timestamps
Necessary since the timestamps from QuantAQ are in a weird format and need to be formatted to a format that works with the openair plotting package. An added column rounding the times to the nearest minute is calculated since two data-frames will be merged later in this script on the basis of time.

```{r}
# Function to reformat time-stamps to time object and round to nearest minute
improve_timestamps <- function(df) {
  df %>%
    # Reformat timestamps to sensible format
    mutate(date = as.POSIXct(timestamp, tz = "America/New_York")) %>%
    # Round times to nearest minute
    mutate(date = round_date(date, unit = "minute"))
}
```

### Filter by relevant times
Each participant contains data for periods where both the sham and actual purifier was running. This function filters the relevant time periods and adds an added variable to track sham and HEPA (actual) readings.
```{r}
include_case <- function(df, person, cd) {
  df %>%
    # Select current participant
    filter(participant_id == person) %>%
    # Add case column
    mutate(case = case_when(
      # Before purifier is switched on
      # Note: 'cd' is the table 'current_dates' in function call
      between(date, cd$dt_start, cd$dt_hepa) ~ 'before',
      # After purifier is switched on
      between(date, cd$dt_hepa, cd$dt_end) ~ 'after'))
}
```

## Main Code Run
### Load all data. 
Ensure that all functions in the code blocks after this loop are loaded. Run this carefully, checking everything, and only once!
```{r}
# Initialize master dataframe for all data
all_df <- data.frame()

# Loop through each participant
for (file_name in list.files(path_to_data)) {
  # Read csv
  file_path <- paste0(path_to_data, file_name)
  df <- read_csv(file_path, show_col_types = FALSE)

  # Split file name into different parts
  name_split <- strsplit(file_name, "[_.]")[[1]] %>% head(-1)
  person <- name_split[3]
  env <- name_split[4]
  place <- name_split[5]
  
  # Add the participant ID, environment, and room (if present, else NA)
  df <- mutate(df, participant_id = person, environment = env, room = place)

  # Append to main dataframe
  all_df <- rbind(all_df, df)
  
  print(paste("Loaded participant", person, env, place))
}

```

### Process all data to remove unnecessary columns and round time values 
This helps in syncing data across different sensors later - functions here can be found in the 'Helper Functions' section.
```{r}
# Clean data (look at helper functions)
clean_df <- all_df %>%
  # Reformat timestamps and round to nearest minute
  improve_timestamps() %>%
  select(date, environment, room, participant_id, pm1, pm25, pm10) %>%
  
  # Remove repeat readings
  distinct(participant_id, room, date, environment, .keep_all = TRUE)
```


```{r}
# List of participants (by default all, feel free to set to custom)
participants <- unique(clean_df$participant_id)

# Filter by time to find whether before or after HEPA purifier installation
case_df <- data.frame()
for (person in participants) {
  # Filter indoor (dates match outdoor) and by current participant
  current_dates <- time_map %>%
    filter(participant_id == person) %>% 
    head(1)
  
  # Filter by date for sham and hepa (see helper function)
  df <- include_case(clean_df, person, current_dates)
  # Append to overall dataframe
  case_df <- rbind(case_df, df)
}
```

```{r}
# Crucial filtering based on sanity checks (nothing for now)
main_df <- case_df
```

Run this code chunk only ONCE
```{r}
# filter out NA and infinite values in data
main_df[sapply(main_df, is.infinite)] <- NA
main_df <- main_df %>%
  filter(complete.cases(across(-room))) %>%
  # Remove repeat readings
  distinct(case, participant_id, date, environment, room, .keep_all = TRUE)
```


### Save Data
The `main_df` dataframe is saved to `cleaned_modpm.RData`
```{r}
save(main_df, file = paste0("cleaning/Roxbury/IB/", "cleaned_modpm.RData"))
```
